"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = require("three");
const Zappar = require("@zappar/zappar");
const defaultpipeline_1 = require("./defaultpipeline");
var CameraPoseMode;
(function (CameraPoseMode) {
    CameraPoseMode[CameraPoseMode["Default"] = 0] = "Default";
    CameraPoseMode[CameraPoseMode["Attitude"] = 1] = "Attitude";
    CameraPoseMode[CameraPoseMode["AnchorOrigin"] = 2] = "AnchorOrigin";
})(CameraPoseMode = exports.CameraPoseMode || (exports.CameraPoseMode = {}));
var CameraMirrorMode;
(function (CameraMirrorMode) {
    CameraMirrorMode[CameraMirrorMode["None"] = 0] = "None";
    CameraMirrorMode[CameraMirrorMode["Poses"] = 1] = "Poses";
    CameraMirrorMode[CameraMirrorMode["CSS"] = 2] = "CSS";
})(CameraMirrorMode = exports.CameraMirrorMode || (exports.CameraMirrorMode = {}));
class Camera extends THREE.Camera {
    constructor(pipeline) {
        super();
        this.backgroundTexture = new THREE.Texture();
        this.poseMode = CameraPoseMode.Default;
        this.rearCameraMirrorMode = CameraMirrorMode.None;
        this.userCameraMirrorMode = CameraMirrorMode.Poses;
        this._currentMirrorMode = CameraMirrorMode.None;
        this.isPerspectiveCamera = true;
        this._cameraRunningRear = null;
        this._hasSetCSSScaleX = false;
        this.pipeline = pipeline || defaultpipeline_1.getDefaultPipeline();
        this.rawPose = this.pipeline.cameraPoseDefault();
        this.rearCameraSource = new defaultpipeline_1.CameraSource(Zappar.cameraDefaultDeviceID(), this.pipeline);
        this.userCameraSource = new defaultpipeline_1.CameraSource(Zappar.cameraDefaultDeviceID(true), this.pipeline);
        this.matrixAutoUpdate = false;
        document.addEventListener("visibilitychange", () => {
            document.visibilityState == "visible" ? this._resume() : this._pause();
        });
    }
    _pause() {
        this.userCameraSource.pause();
        this.rearCameraSource.pause();
    }
    _resume() {
        if (this._cameraRunningRear === null)
            return;
        this._cameraRunningRear ? this.rearCameraSource.start() : this.userCameraSource.start();
    }
    start(userFacing) {
        userFacing ? this.userCameraSource.start() : this.rearCameraSource.start();
        this._cameraRunningRear = !userFacing;
    }
    setPoseModeAnchorOrigin(a) {
        this.poseAnchorOrigin = a;
        this.poseMode = CameraPoseMode.AnchorOrigin;
    }
    get currentMirrorMode() {
        return this._currentMirrorMode;
    }
    updateFrame(renderer) {
        // ThreeJS manages its GL state for optimal performance
        // Reset it here so it's predictable for processGL
        renderer.state.reset();
        this.pipeline.processGL();
        // processGL changes the GL viewport during camera frame processing
        // so set it back to the full render area
        renderer.getContext().viewport(0, 0, renderer.domElement.width, renderer.domElement.height);
        // Return to ThreeJS's standard state since processGL will have altered some state
        renderer.state.reset();
        // Update to using the latest tracking frame data
        this.pipeline.frameUpdate();
        this._currentMirrorMode = this.pipeline.cameraFrameUserFacing() ? this.userCameraMirrorMode : this.rearCameraMirrorMode;
        if (this._currentMirrorMode !== CameraMirrorMode.CSS && this._hasSetCSSScaleX) {
            renderer.domElement.style.transform = "";
            this._hasSetCSSScaleX = false;
        }
        else if (this._currentMirrorMode === CameraMirrorMode.CSS && !this._hasSetCSSScaleX) {
            renderer.domElement.style.transform = "scaleX(-1)";
            this._hasSetCSSScaleX = true;
        }
        // Get the projection matrix for the camera from the Zappar library
        let model = this.pipeline.cameraModel();
        let projection = Zappar.projectionMatrixFromCameraModel(model, renderer.domElement.width, renderer.domElement.height);
        this.projectionMatrix.fromArray(projection);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        // Get the pose of the camera from the Zappar library
        switch (this.poseMode) {
            case CameraPoseMode.Default:
                this.rawPose = this.pipeline.cameraPoseDefault();
                break;
            case CameraPoseMode.Attitude:
                this.rawPose = this.pipeline.cameraPoseWithAttitude(this._currentMirrorMode === CameraMirrorMode.Poses);
                break;
            case CameraPoseMode.AnchorOrigin:
                this.rawPose = this.poseAnchorOrigin ? this._getOriginPose() : this.pipeline.cameraPoseDefault();
                break;
        }
        this._updateBackgroundTexture(renderer);
    }
    updateMatrixWorld(force) {
        this.matrix.fromArray(this.rawPose);
        super.updateMatrixWorld(force);
    }
    _getOriginPose() {
        if (!this.poseAnchorOrigin)
            return this.pipeline.cameraPoseDefault();
        return this.pipeline.cameraPoseWithOrigin(this.poseAnchorOrigin.poseCameraRelative(this._currentMirrorMode === CameraMirrorMode.Poses));
    }
    _updateBackgroundTexture(r) {
        this.pipeline.cameraFrameUploadGL();
        let texture = this.pipeline.cameraFrameTextureGL();
        if (!texture)
            return;
        // Update the underlying WebGL texture of the ThreeJS texture object
        // to the one provided by the Zappar library
        let properties = r.properties.get(this.backgroundTexture);
        properties.__webglTexture = texture;
        properties.__webglInit = true;
        // The Zappar library provides a 4x4 UV matrix to display the camera
        // texture on a fullscreen quad with 0,0 -> 1,1 UV coordinates
        let view = new THREE.Matrix4();
        view.fromArray(this.pipeline.cameraFrameTextureMatrix(r.domElement.width, r.domElement.height, this._currentMirrorMode === CameraMirrorMode.Poses));
        // ThreeJS's Texture object uses a 3x3 matrix, so convert from our 4x4 matrix
        let textureMatrix3 = new THREE.Matrix3();
        textureMatrix3.setFromMatrix4(view);
        textureMatrix3.elements[6] = view.elements[12];
        textureMatrix3.elements[7] = view.elements[13];
        textureMatrix3.elements[8] = 1;
        // The typings for ThreeJS's Texture object does not include the matrix properties
        // so we have to cast here
        this.backgroundTexture.matrixAutoUpdate = false;
        this.backgroundTexture.matrix = textureMatrix3;
    }
}
exports.Camera = Camera;
