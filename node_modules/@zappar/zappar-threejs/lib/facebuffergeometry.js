"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = require("three");
const three_1 = require("three");
const facemeshloader_1 = require("./facemeshloader");
let faceMeshSingleton;
class FaceBufferGeometry extends THREE.BufferGeometry {
    constructor(faceMesh) {
        super();
        this._hasSetIndices = false;
        this._hasSetUVs = false;
        this._calculateNormals = true;
        if (!faceMesh) {
            if (!faceMeshSingleton) {
                faceMeshSingleton = (new facemeshloader_1.FaceMeshLoader()).load();
            }
            faceMesh = faceMeshSingleton;
        }
        this._faceMesh = faceMesh;
    }
    _updateIndices() {
        if (this._hasSetIndices)
            return;
        if (this._faceMesh.indices.length === 0)
            return;
        this.setIndex(new THREE.Uint16BufferAttribute(this._faceMesh.indices, 1));
        this._hasSetIndices = true;
    }
    _updateUVs() {
        if (this._hasSetUVs)
            return;
        if (this._faceMesh.uvs.length === 0)
            return;
        this.setAttribute("uv", new three_1.BufferAttribute(this._faceMesh.uvs, 2));
        this._hasSetUVs = true;
    }
    get calculateNormals() {
        return this._calculateNormals;
    }
    set calculateNormals(b) {
        this._calculateNormals = b;
        if (!this._calculateNormals) {
            this.removeAttribute("normal");
            delete this._normals;
        }
    }
    updateFromFaceAnchorGroup(f) {
        if (this._faceMesh.vertices.length === 0)
            return;
        if (!f.currentAnchor)
            return;
        this.updateFromFaceAnchor(f.currentAnchor);
    }
    updateFromFaceAnchor(f) {
        this.updateFromIdentityExpression(f.identity, f.expression);
    }
    updateFromIdentityExpression(identity, expression) {
        if (this._faceMesh.vertices.length === 0)
            return;
        this._updateIndices();
        this._updateUVs();
        this._faceMesh.updateFromIdentityExpression(identity, expression);
        if (!this._vertices) {
            this._vertices = new Float32Array(this._faceMesh.vertices.length);
            this._verticesAttribute = new three_1.BufferAttribute(this._vertices, 3);
            this.setAttribute("position", this._verticesAttribute);
        }
        this._vertices.set(this._faceMesh.vertices);
        if (this._verticesAttribute)
            this._verticesAttribute.needsUpdate = true;
        if (!this.calculateNormals)
            return;
        if (!this._normals) {
            this._normals = new Float32Array(this._faceMesh.normals.length);
            this._normalsAttribute = new three_1.BufferAttribute(this._normals, 3);
            this.setAttribute("normal", this._normalsAttribute);
        }
        this._normals.set(this._faceMesh.normals);
        if (this._normalsAttribute)
            this._normalsAttribute.needsUpdate = true;
    }
}
exports.FaceBufferGeometry = FaceBufferGeometry;
