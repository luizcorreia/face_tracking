"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const event_1 = require("./event");
const zappar_1 = require("./zappar");
class FaceTracker {
    constructor(_pipeline) {
        this._pipeline = _pipeline;
        this.onVisible = new event_1.Event1();
        this.onNotVisible = new event_1.Event1();
        this.onNewAnchor = new event_1.Event1();
        this.visible = new Set();
        this.anchors = new Map();
        this._visibleLastFrame = new Set();
        this._frameUpdate = () => {
            let newAnchors = new Set();
            // Swap the visible and visibleLastFrame so we can avoid a set allocation
            let swap = this.visible;
            this.visible = this._visibleLastFrame;
            this._visibleLastFrame = swap;
            this.visible.clear();
            let num = this._z.face_tracker_anchor_count(this._impl);
            for (let i = 0; i < num; i++) {
                let id = this._z.face_tracker_anchor_id(this._impl, i);
                let anchor = this.anchors.get(id);
                let isNew = false;
                if (!anchor) {
                    anchor = {
                        onVisible: new event_1.Event(),
                        onNotVisible: new event_1.Event(),
                        id: id,
                        poseCameraRelative: mirror => this._z.face_tracker_anchor_pose_camera_relative(this._impl, i, mirror === true),
                        pose: (cameraPose, mirror) => this._z.face_tracker_anchor_pose(this._impl, i, cameraPose, mirror === true),
                        identity: new Float32Array(50),
                        expression: new Float32Array(29),
                        visible: true
                    };
                    isNew = true;
                    this.anchors.set(id, anchor);
                    newAnchors.add(anchor);
                }
                anchor.visible = true;
                anchor.identity = this._z.face_tracker_anchor_identity_coefficients(this._impl, i);
                anchor.expression = this._z.face_tracker_anchor_expression_coefficients(this._impl, i);
                this.visible.add(anchor);
            }
            // Events
            for (let anchor of newAnchors)
                this.onNewAnchor.emit(anchor);
            for (let anchor of this.visible) {
                if (!this._visibleLastFrame.has(anchor)) {
                    this.onVisible.emit(anchor);
                    anchor.onVisible.emit();
                }
                else {
                    this._visibleLastFrame.delete(anchor);
                }
            }
            for (let anchor of this._visibleLastFrame) {
                this.onNotVisible.emit(anchor);
                anchor.onNotVisible.emit();
            }
        };
        this._pipeline._onFrameUpdateInternal.bind(this._frameUpdate);
        this._z = zappar_1.z();
        this._impl = this._z.face_tracker_create(this._pipeline._getImpl());
    }
    destroy() {
        this._pipeline._onFrameUpdateInternal.unbind(this._frameUpdate);
        this.anchors.clear();
        this.visible.clear();
        this._z.face_tracker_destroy(this._impl);
    }
    loadModel(src) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof src === "string") {
                src = yield (yield fetch(src)).arrayBuffer();
            }
            this._z.face_tracker_model_load_from_memory(this._impl, src);
        });
    }
    loadDefaultModel() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._z.face_tracker_model_load_default(this._impl);
        });
    }
    get enabled() {
        return this._z.face_tracker_enabled(this._impl);
    }
    set enabled(e) {
        this._z.face_tracker_enabled_set(this._impl, e);
    }
    get maxFaces() {
        return this._z.face_tracker_max_faces(this._impl);
    }
    set maxFaces(m) {
        this._z.face_tracker_max_faces_set(this._impl, m);
    }
}
exports.FaceTracker = FaceTracker;
